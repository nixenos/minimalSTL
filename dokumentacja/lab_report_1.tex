\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage[polish]{babel}
\usepackage{datetime}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{blindtext,graphicx}
\usepackage[absolute]{textpos}
\usepackage{titling}

\setlength{\TPHorizModule}{1cm}
\setlength{\TPVertModule}{1cm}

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\begin{document}
\title{Implementacja kontenerów z biblioteki STL} % Title

\author{Wojciech \textsc{Janota}} % Author name

\selectlanguage{polish}
\date{\today} % Date for the report

\maketitle % Insert the title, author and date

\begin{textblock}{5}(14,1)
\noindent\Large Politechnika Śląska \newline
\noindent Wydział Automatyki Elektroniki i Informatyki
\end{textblock}
\begin{figure}[h!]
  \centering
  \includegraphics[width=5cm]{LOGO}
\end{figure}
\newpage{}
\section{Opis projektu}
\paragraph{}
Głównym założeniem projetku było stworzenie odpowiedników kontenerów \newline z biblioteki Standard Template Library.
Założyłem, że zaimplementuję następujące kontenery:
\begin{itemize}
  \item vector
  \item queue
  \item priority-queue
  \item stack
  \item list
  \item set
  \item binary tree
\end{itemize}

\section{Opis budowy klas}
\subsection{Container}
\paragraph{}
Zgodnie ze złożonymi wcześniej wstępnymi szkicami projektu główna klasa bazowa, \texttt{container}, odpowiada za
zarządzanie pamięcią i podstawowe operacje na wewnętrznej tablicy dynamicznej. Po niej dziedziczą klasy \texttt{vector, queue,
priority-queue, stack, set}. Jest w niej zaimplementowany konstruktor \newline i destruktor, które są wspólne dla wszystkich
kontenerów po niej dziedziczących, podstawowe "getery" i "setery" dla wewnętrznych zmiennych, operator[],
podstawowe funkcje operujące na wewnętrznej tablicy dynamicznej (dodawanie, usuwanie elementów) oraz funkcja
sortująca, jako metoda chroniona. Klasa jest abstrakcyjna, aby uniemożliwić stworzenie obiektu na jej podstawie.

\subsection{Vector}
\paragraph{}
\texttt{Vector} to kontener dziedziczący po \texttt{container} będący bardziej zaawansowaną tablicą dynamiczną.
Zawiera w sobie mechanizmy obsługi pamięci, inteligentnie zarządza swoją wielkością. Dodawanie elementów
na początek tego kontenera lub w środku jest bardzo kosztowne czasowo, ponieważ wymagane jest przesunięcie
wszystkich elementów od indeksu na którym wstawiany jest nowy element o jedną pozycję w prawo. Jest za to bardzo
łatwy w obsłudze (jak tablica dynamiczna), w miarę łatwy w implementacji i w większości zastosowań dość szybki.

\subsection{Queue}
\paragraph{}
\texttt{Queue}, czyli kolejka to kontener FIFO (First In First Out). Umożliwia dodawanie elementów na koniec,
pobranie i wyrzucenie pierwszego elementu i podstawowe metody takie jak zwrócenie wielkości kontenera.

\subsection{Priority queue}
\paragraph{}
Jest to kolejka priorytetowa, na podstawie podanego priorytetu (MIN, MAX) na początku kolejki zawsze znajduje się
największy lub najmniejszy element. Reszta działania jest identyczna jak w przypadku zwykłej kolejki.

\subsection{Stack}
\paragraph{}
\texttt{Stack}, czyli stos to kontener FILO (First In Last Out). Możliwe jest dodanie elementu na górę stosu
i zdjęcie elementu ze stosu.

\subsection{Set}
\paragraph{}
\texttt{Set} to kontener samosortujący, poprzez wstawienie elementu w odpowiednie miejsce. Zaimplementowałem
odpowiednik STL-owego multiseta sortującego tylko rosnąco, zwracającego także indeks pierwszego elementu nie mniejszego i nie większego od podanego.

\subsection{List}
\paragraph{}
Lista jest odpowiednikiem vectora, używającym listy jako wewnętrzego sposobu przechowywania danych. Umozliwia to
dodawanie elementu na początku i na końcu w czasie stałym, jednak powoduje również, że operacje pobierania elementu z
konkretnego indeksu są wykonywane w czasie liniowym.

\subsection{Binary tree}
\paragraph{}
Drzewo binarne jest strukturą sortująca, przechowującą kolejne elementy jako kolejne węzły w drzewie binarnym.
Moja implementacja umożliwia wstawianie do drzewa, wypisanie drzewa w kolejności in-order, usuwanie poszczególnych
węzłów oraz pobranie prawego i lewego syna podanego elementu.

\section{Szczegółowy opis klas, zależności i metod}

\paragraph{}
Szczegółowa dokumentacja została wygenerowana przez narzędzie doxygen.

\section{Problemy}
\paragraph{}
W związku z bardzo ograniczonym czasem na napisanie projektu, nie udało się zaimplementować mapy, a binary tree
mogłoby zostać jeszcze udoskonalone. Używanie szablonów momentami bywa nieintuicyjne, jednak udało się zaimplementować
powyższe kontenery w ich użyciem z czego jestem zadowolony.

\section{Testowanie}
\paragraph{}
Do testowania wycieków pamięci użyłem narzędzia valgrind. Projekt okazał się od nich wolny. Przetestowane zostały
także wszystkie metody poszczególnych klas. Kod został sformatowany z użyciem clang-format w standardzie LLVM.

\section{Wnioski}
\paragraph{}
Po napisaniu w miarę funkcjonalnych odpowiedników kontenerów z STL mogę stwierdzić, że znacząco ułatwiają one
pracę z użyciem języka C++. Pisząc je należy pamiętać o pewnych niuansach, które pominięte mogą okazać się
katasrofalne, jak np. niepoprawne poszerzanie i zwężanie vectora może spowodować błąd SIGSEGV, ponieważ
nagle program odwoła się do niepoprawnej pamięci. Muszę również stwierdzić, że pisanie projektu w tak krótkim czasie
jest o wiele trudniejsze i ciężej jest rozłożyć efektywnie pracę. Rozumiem, że wynika to z obecnej sytuacji, jednak chcę
zwrócić uwagę na problem, jaki tak krótki czas może sprawić.

\section{Dokuemntacja wygenerowana przez doxygen}

\end{document}